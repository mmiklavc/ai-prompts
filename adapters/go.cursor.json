{
  "name": "GO Adapter",
  "description": "Adapter rules for this stack.",
  "matches": [
    "**/*.go",
    "go.mod",
    "go.sum"
  ],
  "content": "# Go Adapter\n\n**Idioms**\n- Effective Go; early returns; zero-value-usable types; minimal interfaces; avoid stutter; cohesive packages; exported identifiers have doc comments.\n\n**Errors**\n- Return errors, wrap with `%w`; use `errors.Is/As`; include actionable context (no secrets).\n\n**Concurrency**\n- Accept `context.Context` at boundaries; apply `WithTimeout/WithDeadline` once near the edge; cancel/close on all exits; avoid goroutine leaks; prefer owned goroutines and channels; verify with `go test -race`.\n\n**Testing**\n- Table-driven tests; deterministic randomness; use fakes over real I/O; add benchmarks when perf-sensitive.\n\n**Formatting & Imports**\n- `gofmt -s` everywhere; organize imports with `goimports` or `gci`; optionally `gofumpt` if present.\n\n**Runbook**\n```\ngo fmt ./...\ngo vet ./...\ngo test ./... -race -cover\n# optional if configured\nstaticcheck ./...\ngovulncheck ./...\ngci write ./...        # or: goimports -w .\ngofumpt -w .\n```\n\n**Security & Performance**\n- Validate inputs; sanitize paths; never log secrets; constant-time compares for secrets (`crypto/subtle`).\n- Bound memory and concurrency; stream large payloads; avoid copying big slices/strings in hot loops.\n- If perf-sensitive: identify critical path, run `go test -bench .`, capture `pprof`, document big‑O trade-offs.\n\n**References**\n- Effective Go — https://go.dev/doc/effective_go\n- Go Code Review Comments — https://github.com/golang/go/wiki/CodeReviewComments\n"
}